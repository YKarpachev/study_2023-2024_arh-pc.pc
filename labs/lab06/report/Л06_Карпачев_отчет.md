---
## Front matter
title: "Лабораторная работа №6"
subtitle: "Дисциплина: Архитектура компьютера"
author: "Карпачев Ярослав Олегович"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

  Освоение арифметических инструкций языка ассемблера NASM. 

# Задание

1. Символьные и численные данные в NASM 
2. Выполнение арифметических операций в NASM 
3. Выполнение заданий для самостоятельной работы 


# Теоретическое введение

  Большинство инструкций на языке ассемблера требуют обработки операндов. Адрес операнда предоставляет место, где хранятся данные, подлежащие обработке. Это могут быть данные хранящиеся в регистре или в ячейке памяти.

- Регистровая адресация – операнды хранятся в регистрах и в команде используются имена этих регистров, например: mov ax,bx.
- Непосредственная адресация – значение операнда задается непосредственно в команде, Например: mov ax,2.
- Адресация памяти – операнд задает адрес в памяти. В команде указывается символическое обозначение ячейки памяти, над содержимым которой требуется выполнить операцию.

  Ввод информации с клавиатуры и вывод её на экран осуществляется в символьном виде. Кодирование этой информации производится согласно кодовой таблице символов ASCII. ASCII – сокращение от American Standard Code for Information Interchange (Американский стандартный код для обмена информацией). Согласно стандарту ASCII каждый символ кодируется одним байтом.
  Среди инструкций NASM нет такой, которая выводит числа (не в символьном виде). Поэтому, например, чтобы вывести число, надо предварительно преобразовать его цифры в ASCII-коды этих цифр и выводить на экран эти коды, а не само число. Если же выводить число на экран непосредственно, то экран воспримет его не как число, а как последовательность ASCII-символов – каждый байт числа будет воспринят как один ASCII-символ – и выведет на экран эти символы.
  Аналогичная ситуация происходит и при вводе данных с клавиатуры. Введенные данные будут представлять собой символы, что сделает невозможным получение корректного результата при выполнении над ними арифметических операций.
  Для решения этой проблемы необходимо проводить преобразование ASCII символов в числа и обратно.

# Выполнение лабораторной работы

## Символьные и численные данные в NASM

  С помощью утилиты mkdir создал каталог для программ лабораторной работы № 6, перешлел в него и создал файл lab6-1.asm Скопировал в текущий каталог файл in_out.asm с помощью утилиты cp, т.к. он будет использоваться. (рис. @fig:001).

![Создание файла lab6-1.asm](image/1.png){ #fig:001 width=70% }

  Ввел в файл lab6-1.asm текст программы из листинга 6.1 (рис. @fig:002).

![Редактированный файл](image/2.png){ #fig:002 width=70% }

  Создал исполняемый файл, скомпилировал и запустил его (рис. @fig:003). Вывод - символ j, потому что программа вывела символ по системе ASCII сумме двоичных кодов символов 4 и 6.

![Создание исполняемого кода и его запуск](image/3.png){ #fig:003 width=70% }

   Исправил текст программы: поменяла символы "6" и "4" на цифры 6 и 4 (рис. @fig:004). Скомпилировал файл и запустил его (рис. @fig:005). Теперь вывелся символ с кодом 10, это символ перевода строки, поэтому он не отображается при выводе на экран.
   
![Редактированнный файла](image/1-2.png){ #fig:004 width=70% }

![Создание исполняемого файла и его запуск](image/1-3.png){ #fig:005 width=70% }

  Создал lab6-2.asm в каталоге ~/work/arch-pc/lab06 и ввел текст программы из листинга 6.2 (рис. @fig:006) и (рис. @fig:100).

![Создание файла lab6-2.asm](image/4.png){ #fig:006 width=70% }

![Редактированнный файла](image/5.png){ #fig:100 width=70% }

  Скомпилировал файл и запустил его (рис. @fig:007). Теперь вывело число 106, потому что программа позволяет вывести число, а не символ, хотя происходит сложение кодов символов "6" и "4".

![Компиляция файла и его запуск](image/6.png){ #fig:007 width=70% }

  Заменил в тексте программы в файле lab6-2.asm символы "6" и "4" на числа 6 и 4 (рис. @fig:008).
  
![Редактирование программы](image/2-2.png){ #fig:008 width=70% }

  Создал  и запустил новый исполняемый файл (рис. @fig:009). Теперь программа складывает не соответствующие символам коды в системе ASCII, а сами числа, поэтому вывод 10.
  
![запуск файла](image/2-3.png){ #fig:009 width=70% }

  Заменяю в тексте программы iprintLF на iprint (рис. @fig:010). Создал и скомпилировал файл (рис. @fig:010). Вывод не изменился - 10, но теперь iprint не добавляет к выводу символ переноса строки, в отличие от iprintLF.

![запуск нового варианта](image/2-5.png){ #fig:010 width=70% }


## Выполнение арифметических операций в NASM

  Создал файл lab6-3.asm с помощью утилиты touch (рис. @fig:011). Ввел в созданный файл текст программы для вычисления значения выражения f(x) = (5 * 2 + 3)/3 (рис. @fig:011) и (рис. @fig:101).

![Создание файла](image/7.png){ #fig:011 width=70% }

![Редаактирование файла](image/8.png){ #fig:101 width=70% }

  Скомпилировал файл и запустил его (рис. [-@fig:012]).

![Запуск исполняемого файла](image/9.png){ #fig:012 width=70% }

  Изменил программу так, чтобы она вычисляла значение выражения f(x) = (4 * 6 + 2)/5. Создал и запустил новый исполняемый файл (рис. @fig:013). Программа отработала верно.

![Запуск нового исполняемого файла](image/9-1.png){ #fig:013 width=70% }

  Создал файл variant.asm с помощью touch (рис. @fig:106). Ввел код из листинга 6.4 (рис. @fig:107). Создала исполняемый файл и запустила его. Ввела номер своего студенческого билета и получила номер своего варианта -- 11 (рис. @fig:014). Проверила правильность выполнения, вычислив номер варианта аналитически.

![Создание файла](image/10.png){ #fig:106 width=70% }

![Редактирование файла](image/11.png){ #fig:107 width=70% }

![Запуск файла](image/12.png){ #fig:014 width=70% }

### Ответы на вопросы по программе

1. За вывод сообщения "Ваш вариант" отвечают строки кода:

```NASM
mov eax,rem
call sprint
```

2. Инструкция mov ecx, x используется, чтобы положить адрес вводимой строки x в регистр ecx
  mov edx, 80 - запись в регистр edx длины вводимой строки
  call sread - вызов подпрограммы из внешнего файла, обеспечивающей ввод сообщения с клавиатуры

3. call atoi используется для вызова подпрограммы из внешнего файла, которая преобразует ascii-код символа в целое число и записывает результат в регистр eax

4. За вычисления варианта отвечают строки:

```NASM
xor edx,edx ; обнуление edx для корректной работы div
mov ebx,20 ; ebx = 20
div ebx ; eax = eax/20, edx - остаток от деления
inc edx ; edx = edx + 1
```

5. При выполнении инструкции div ebx остаток от деления записывается в регистр edx

6. Инструкция inc edx увеличивает значение регистра edx на 1

7. За вывод на экран результатов вычислений отвечают строки:

```NASM
mov eax,edx
call iprintLF
```

## Выполнение заданий для самостоятельной работы

  Создал myprogram.asm. Открыл его, ввела код программы для вычисления значения выражения (x + 2)^2 (вариант 3) (рис. @fig:111). Создал и запустил исполняемый файл. При вводе значения 1 на входе вывод программы = 10. При вводе значения 7 на входе вывод программы = 70. Значит, программа работает верно. (рис. @fig:015).

![Код программы](image/14.png){ #fig:111 width=70% }

![Запуск программы для выполнения задания для самостоятельной работы](image/15.png){ #fig:015 width=70% }

# Выводы

  При выполнении данной лабораторной работы я освоил арифметические инструкции языка ассемблера NASM.

